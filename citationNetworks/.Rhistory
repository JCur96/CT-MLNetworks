# plot2 <- plot(delete.vertices(simplify(net), degree(net)==0), vertex.size=2,
#               vertex.label=NA,
#               vertex.color= fullData$color,
#               edge.arrow.size=.2, layout = coords)
# comStructure <- modularity(net, fullData$search)
# comStructure
#
# ################ useful ###############
# # what search did these appear in?
# # proportion of the two searches in each module
#
# cluster <- cluster_louvain(net)
# cluster
# # modularity(cluster)
# # modularity(net, membership(cluster))
# members <- igraph::membership(cluster)
# members
# modularity(net, members)
#
# class(members)
# membersDf <- as.data.frame(members)
# write.csv(as.numeric(members), "../Data/membership.csv")
# need to get the csv from the python version
# bind the dfs
# communities <- read.csv("../Data/membership.csv")
communities <- read.csv("../Data/pythonCommunityData.csv")
communities
# names(communities)[names(communities) == "X"] <- "ID"
# names(communities)[names(communities) == "x"] <- "Community"
names(communities)[names(communities) == "community"] <- "Community"
communities <- communities[c("ID", "Community")]
fullData <- merge(fullData, communities, all = T, by = 'ID')
head(fullData)
# now can see what search each module contains
# ok maybe drop irrelevant stuff
partData <- fullData[c("ID", "search", "Community")]
groupedData <- partData %>% dplyr::group_split(Community)
groupedData[[7]]
# great, now code for proportion of each comm of each search?
tab <- groupedData[[7]]
counts <- dplyr::count(tab, search)
totRows <- nrow(tab)
counts
# count return col2 value 1 the col 2 value 2 over nrow for proportion
CTProp <- counts[1,2] / totRows
MLProp <- counts[2,2] / totRows
CTProp + MLProp
CTProportionList <- c()
for (i in 1:length(groupedData)) {
tab <- groupedData[[i]]
counts <- dplyr::count(tab, search)
totRows <- nrow(tab)
CTProp <- counts[1,2] / totRows
MLProp <- counts[2,2] / totRows
# CTProp + MLProp
CTProportionList <- append(CTProportionList, CTProp)
}
CTPropDf <- as.data.frame(unlist(CTProportionList))
names(CTPropDf)[names(CTPropDf) == "unlist(CTProportionList)"] <- "proportionCT"
CTPropDf$Community <- 1:nrow(CTPropDf)
CTPropDf
partData
partData <- merge(partData, CTPropDf, all=T, by='Community')
head(partData)
for (i in 1:length(groupedData)) {
tab <- groupedData[[i]]
counts <- dplyr::count(tab, search)
totRows <- nrow(tab)
CTProp <- counts[1,2] / totRows
MLProp <- counts[2,2] / totRows
# CTProp + MLProp
CTProportionList <- append(CTProportionList, CTProp)
}
CTPropDf <- as.data.frame(unlist(CTProportionList))
names(CTPropDf)[names(CTPropDf) == "unlist(CTProportionList)"] <- "proportionCT"
CTPropDf$proportionCT
partData
# networkAnalysis.R
set.seed(1)
setwd("C:/docNonNetwork/RProjects/CT-MLNetworks/citationNetworks/Code")
# imports
library(igraph)
library(RColorBrewer)
# read in edgeList data
edges <- read.csv("../Data/edges/edgeList.csv")
# read data in
MLData <- read.csv("../Data/ML/autoScreenedML.csv")
CTData <- read.csv("../Data/CT/autoScreenedCT.csv")
# MLData$search <- 2
# CTData$search <- 1
MLData$search <- 'ML'
CTData$search <- 'CT'
MLData$label <- "ML"
CTData$label <- "CT"
MLData$color <- "gold"
CTData$color <- "blue"
fullData <- merge(MLData, CTData, all = T)
names(fullData)[names(fullData) == "X"] <- "ID"
colnames(fullData)
fullData$ID <- 1:nrow(fullData)
# fullData$ID <- 0:nrow(fullData) ?
write.csv(fullData, "../Data/dataForPythonModules.csv")
# fullData$search <- as.numeric(fullData$search)
colnames(edges)
edges <- edges[c("CitingID", "CitedID")]
colnames(edges)
nodes <- fullData[c("ID")] # slice of just ID and title
# currently this is an undirected shared reference network I think
# or at least it should be as those are the edges
#edges <- fullData[c("ID", "cited_by")]
titles <- fullData[c("ID", "title")]
authors <- fullData[c("ID", "author")]
journal <- fullData[c("ID", "source_title")]
year <- fullData[c("ID", "year")]
search <- fullData[c("ID", "search")]
label <- fullData[c("ID", "label")]
color <- fullData[c("ID", "color")]
references <- fullData[c("ID", "references")]
class(edges)
edges <- as.matrix(edges)
class(edges)
edges
net <- igraph::graph_from_edgelist(edges, directed = TRUE)
net <- set_vertex_attr(net, "title", value = nodes)
net <- set_vertex_attr(net, "author", value = authors)
net <- set_vertex_attr(net, "journal", value = journal)
net <- set_vertex_attr(net, "year", value = year)
net <- set_vertex_attr(net, "search", value = search)
# layout <- layout.fruchterman.reingold(net)
# plot(simplify(net),
#      layout=layout, vertex.size=2,
#      vertex.label=NA,
#      vertex.color= fullData$search,
#      edge.arrow.size=.2)
# plot(delete.vertices(simplify(net), degree(net)==0), vertex.size=2,
#      vertex.label=NA,
#      vertex.color= fullData$search,
#      edge.arrow.size=.2)
# coords = layout_(net, with_mds())
# plot1 <- plot(delete.vertices(simplify(net), degree(net)==0), vertex.size=2,
#      vertex.label=NA,
#      vertex.color= fullData$search,
#      edge.arrow.size=.2, layout = coords)
#
# plot2 <- plot(delete.vertices(simplify(net), degree(net)==0), vertex.size=2,
#               vertex.label=NA,
#               vertex.color= fullData$color,
#               edge.arrow.size=.2, layout = coords)
# comStructure <- modularity(net, fullData$search)
# comStructure
#
# ################ useful ###############
# # what search did these appear in?
# # proportion of the two searches in each module
#
# cluster <- cluster_louvain(net)
# cluster
# # modularity(cluster)
# # modularity(net, membership(cluster))
# members <- igraph::membership(cluster)
# members
# modularity(net, members)
#
# class(members)
# membersDf <- as.data.frame(members)
# write.csv(as.numeric(members), "../Data/membership.csv")
# need to get the csv from the python version
# bind the dfs
# communities <- read.csv("../Data/membership.csv")
communities <- read.csv("../Data/pythonCommunityData.csv")
communities
# names(communities)[names(communities) == "X"] <- "ID"
# names(communities)[names(communities) == "x"] <- "Community"
names(communities)[names(communities) == "community"] <- "Community"
communities <- communities[c("ID", "Community")]
fullData <- merge(fullData, communities, all = T, by = 'ID')
head(fullData)
# now can see what search each module contains
# ok maybe drop irrelevant stuff
partData <- fullData[c("ID", "search", "Community")]
groupedData <- partData %>% dplyr::group_split(Community)
groupedData[[7]]
# great, now code for proportion of each comm of each search?
tab <- groupedData[[7]]
counts <- dplyr::count(tab, search)
totRows <- nrow(tab)
counts
# count return col2 value 1 the col 2 value 2 over nrow for proportion
CTProp <- counts[1,2] / totRows
MLProp <- counts[2,2] / totRows
CTProp + MLProp
CTProportionList <- c()
for (i in 1:length(groupedData)) {
tab <- groupedData[[i]]
counts <- dplyr::count(tab, search)
totRows <- nrow(tab)
CTProp <- counts[1,2] / totRows
MLProp <- counts[2,2] / totRows
# CTProp + MLProp
CTProportionList <- append(CTProportionList, CTProp)
}
CTPropDf <- as.data.frame(unlist(CTProportionList))
names(CTPropDf)[names(CTPropDf) == "unlist(CTProportionList)"] <- "proportionCT"
CTPropDf$Community <- 1:nrow(CTPropDf)
CTPropDf$proportionCT
partData$proportionCT
?merge
partData <- merge(CTPropDf, partData, all=T, by='Community')
head(partData)
communities
# networkAnalysis.R
set.seed(1)
setwd("C:/docNonNetwork/RProjects/CT-MLNetworks/citationNetworks/Code")
# imports
library(igraph)
library(RColorBrewer)
# read in edgeList data
edges <- read.csv("../Data/edges/edgeList.csv")
# read data in
MLData <- read.csv("../Data/ML/autoScreenedML.csv")
CTData <- read.csv("../Data/CT/autoScreenedCT.csv")
# MLData$search <- 2
# CTData$search <- 1
MLData$search <- 'ML'
CTData$search <- 'CT'
MLData$label <- "ML"
CTData$label <- "CT"
MLData$color <- "gold"
CTData$color <- "blue"
fullData <- merge(MLData, CTData, all = T)
names(fullData)[names(fullData) == "X"] <- "ID"
colnames(fullData)
fullData$ID <- 1:nrow(fullData)
# fullData$ID <- 0:nrow(fullData) ?
write.csv(fullData, "../Data/dataForPythonModules.csv")
# fullData$search <- as.numeric(fullData$search)
colnames(edges)
edges <- edges[c("CitingID", "CitedID")]
colnames(edges)
nodes <- fullData[c("ID")] # slice of just ID and title
# currently this is an undirected shared reference network I think
# or at least it should be as those are the edges
#edges <- fullData[c("ID", "cited_by")]
titles <- fullData[c("ID", "title")]
authors <- fullData[c("ID", "author")]
journal <- fullData[c("ID", "source_title")]
year <- fullData[c("ID", "year")]
search <- fullData[c("ID", "search")]
label <- fullData[c("ID", "label")]
color <- fullData[c("ID", "color")]
references <- fullData[c("ID", "references")]
class(edges)
edges <- as.matrix(edges)
class(edges)
edges
net <- igraph::graph_from_edgelist(edges, directed = TRUE)
net <- set_vertex_attr(net, "title", value = nodes)
net <- set_vertex_attr(net, "author", value = authors)
net <- set_vertex_attr(net, "journal", value = journal)
net <- set_vertex_attr(net, "year", value = year)
net <- set_vertex_attr(net, "search", value = search)
# layout <- layout.fruchterman.reingold(net)
# plot(simplify(net),
#      layout=layout, vertex.size=2,
#      vertex.label=NA,
#      vertex.color= fullData$search,
#      edge.arrow.size=.2)
# plot(delete.vertices(simplify(net), degree(net)==0), vertex.size=2,
#      vertex.label=NA,
#      vertex.color= fullData$search,
#      edge.arrow.size=.2)
# coords = layout_(net, with_mds())
# plot1 <- plot(delete.vertices(simplify(net), degree(net)==0), vertex.size=2,
#      vertex.label=NA,
#      vertex.color= fullData$search,
#      edge.arrow.size=.2, layout = coords)
#
# plot2 <- plot(delete.vertices(simplify(net), degree(net)==0), vertex.size=2,
#               vertex.label=NA,
#               vertex.color= fullData$color,
#               edge.arrow.size=.2, layout = coords)
# comStructure <- modularity(net, fullData$search)
# comStructure
#
# ################ useful ###############
# # what search did these appear in?
# # proportion of the two searches in each module
#
# cluster <- cluster_louvain(net)
# cluster
# # modularity(cluster)
# # modularity(net, membership(cluster))
# members <- igraph::membership(cluster)
# members
# modularity(net, members)
#
# class(members)
# membersDf <- as.data.frame(members)
# write.csv(as.numeric(members), "../Data/membership.csv")
# need to get the csv from the python version
# bind the dfs
# communities <- read.csv("../Data/membership.csv")
communities <- read.csv("../Data/pythonCommunityData.csv")
communities
# names(communities)[names(communities) == "X"] <- "ID"
# names(communities)[names(communities) == "x"] <- "Community"
names(communities)[names(communities) == "community"] <- "Community"
communities <- communities[c("ID", "Community")]
fullData <- merge(fullData, communities, all = T, by = 'ID')
head(fullData)
# now can see what search each module contains
# ok maybe drop irrelevant stuff
partData <- fullData[c("ID", "search", "Community")]
groupedData <- partData %>% dplyr::group_split(Community)
groupedData[[7]]
# great, now code for proportion of each comm of each search?
tab <- groupedData[[7]]
counts <- dplyr::count(tab, search)
totRows <- nrow(tab)
counts
# count return col2 value 1 the col 2 value 2 over nrow for proportion
CTProp <- counts[1,2] / totRows
MLProp <- counts[2,2] / totRows
CTProp + MLProp
CTProportionList <- c()
for (i in 1:length(groupedData)) {
tab <- groupedData[[i]]
counts <- dplyr::count(tab, search)
totRows <- nrow(tab)
CTProp <- counts[1,2] / totRows
MLProp <- counts[2,2] / totRows
# CTProp + MLProp
CTProportionList <- append(CTProportionList, CTProp)
}
CTPropDf <- as.data.frame(unlist(CTProportionList))
names(CTPropDf)[names(CTPropDf) == "unlist(CTProportionList)"] <- "proportionCT"
CTPropDf$Community <- 0:nrow(CTPropDf)
CTPropDf$Community <- 0:nrow(CTPropDf)-1
CTPropDf$Community <- 0:(nrow(CTPropDf)-1)
CTPropDf$proportionCT
partData$proportionCT
# partData$proportionCT
partData <- merge(partData, CTPropDf, all=T, by='Community')
head(partData)
# networkAnalysis.R
set.seed(1)
setwd("C:/docNonNetwork/RProjects/CT-MLNetworks/citationNetworks/Code")
# imports
library(igraph)
library(RColorBrewer)
# read in edgeList data
edges <- read.csv("../Data/edges/edgeList.csv")
# read data in
MLData <- read.csv("../Data/ML/autoScreenedML.csv")
CTData <- read.csv("../Data/CT/autoScreenedCT.csv")
# MLData$search <- 2
# CTData$search <- 1
MLData$search <- 'ML'
CTData$search <- 'CT'
MLData$label <- "ML"
CTData$label <- "CT"
MLData$color <- "gold"
CTData$color <- "blue"
fullData <- merge(MLData, CTData, all = T)
names(fullData)[names(fullData) == "X"] <- "ID"
colnames(fullData)
fullData$ID <- 1:nrow(fullData)
# fullData$ID <- 0:nrow(fullData) ?
write.csv(fullData, "../Data/dataForPythonModules.csv")
# fullData$search <- as.numeric(fullData$search)
colnames(edges)
edges <- edges[c("CitingID", "CitedID")]
colnames(edges)
nodes <- fullData[c("ID")] # slice of just ID and title
# currently this is an undirected shared reference network I think
# or at least it should be as those are the edges
#edges <- fullData[c("ID", "cited_by")]
titles <- fullData[c("ID", "title")]
authors <- fullData[c("ID", "author")]
journal <- fullData[c("ID", "source_title")]
year <- fullData[c("ID", "year")]
search <- fullData[c("ID", "search")]
label <- fullData[c("ID", "label")]
color <- fullData[c("ID", "color")]
references <- fullData[c("ID", "references")]
class(edges)
edges <- as.matrix(edges)
class(edges)
edges
net <- igraph::graph_from_edgelist(edges, directed = TRUE)
net <- set_vertex_attr(net, "title", value = nodes)
net <- set_vertex_attr(net, "author", value = authors)
net <- set_vertex_attr(net, "journal", value = journal)
net <- set_vertex_attr(net, "year", value = year)
net <- set_vertex_attr(net, "search", value = search)
# layout <- layout.fruchterman.reingold(net)
# plot(simplify(net),
#      layout=layout, vertex.size=2,
#      vertex.label=NA,
#      vertex.color= fullData$search,
#      edge.arrow.size=.2)
# plot(delete.vertices(simplify(net), degree(net)==0), vertex.size=2,
#      vertex.label=NA,
#      vertex.color= fullData$search,
#      edge.arrow.size=.2)
# coords = layout_(net, with_mds())
# plot1 <- plot(delete.vertices(simplify(net), degree(net)==0), vertex.size=2,
#      vertex.label=NA,
#      vertex.color= fullData$search,
#      edge.arrow.size=.2, layout = coords)
#
# plot2 <- plot(delete.vertices(simplify(net), degree(net)==0), vertex.size=2,
#               vertex.label=NA,
#               vertex.color= fullData$color,
#               edge.arrow.size=.2, layout = coords)
# comStructure <- modularity(net, fullData$search)
# comStructure
#
# ################ useful ###############
# # what search did these appear in?
# # proportion of the two searches in each module
#
# cluster <- cluster_louvain(net)
# cluster
# # modularity(cluster)
# # modularity(net, membership(cluster))
# members <- igraph::membership(cluster)
# members
# modularity(net, members)
#
# class(members)
# membersDf <- as.data.frame(members)
# write.csv(as.numeric(members), "../Data/membership.csv")
# need to get the csv from the python version
# bind the dfs
# communities <- read.csv("../Data/membership.csv")
communities <- read.csv("../Data/pythonCommunityData.csv")
communities
# names(communities)[names(communities) == "X"] <- "ID"
# names(communities)[names(communities) == "x"] <- "Community"
names(communities)[names(communities) == "community"] <- "Community"
communities <- communities[c("ID", "Community")]
fullData <- merge(fullData, communities, all = T, by = 'ID')
head(fullData)
# now can see what search each module contains
# ok maybe drop irrelevant stuff
partData <- fullData[c("ID", "search", "Community")]
groupedData <- partData %>% dplyr::group_split(Community)
groupedData[[7]]
# great, now code for proportion of each comm of each search?
tab <- groupedData[[7]]
counts <- dplyr::count(tab, search)
totRows <- nrow(tab)
counts
# count return col2 value 1 the col 2 value 2 over nrow for proportion
CTProp <- counts[1,2] / totRows
MLProp <- counts[2,2] / totRows
CTProp + MLProp
CTProportionList <- c()
for (i in 1:length(groupedData)) {
tab <- groupedData[[i]]
counts <- dplyr::count(tab, search)
totRows <- nrow(tab)
CTProp <- counts[1,2] / totRows
MLProp <- counts[2,2] / totRows
# CTProp + MLProp
CTProportionList <- append(CTProportionList, CTProp)
}
CTPropDf <- as.data.frame(unlist(CTProportionList))
names(CTPropDf)[names(CTPropDf) == "unlist(CTProportionList)"] <- "proportionCT"
# CTPropDf$Community <- 0:(nrow(CTPropDf)-1) # or
CTPropDf$Community <- 1:nrow(CTPropDf)
CTPropDf$proportionCT
# partData$proportionCT
partData <- merge(partData, CTPropDf, all=T, by='Community')
head(partData)
MLProportionList <- c()
for (i in 1:length(groupedData)) {
tab <- groupedData[[i]]
counts <- dplyr::count(tab, search)
totRows <- nrow(tab)
CTProp <- counts[1,2] / totRows
MLProp <- counts[2,2] / totRows
if (is.na(MLProp)) {
MLProp <- 0
}
# CTProp + MLProp
MLProportionList <- append(MLProportionList, MLProp)
}
MLProportionList
# MLPropDf <- c()
# for (i in 1:length(MLProportionList)) {
#         comm <- i
#         #comm <- MLProportionList[[i]]
#         value <- MLProportionList[[i]][[1]]
#         row <- c(comm, value)
#         MLPropDf <- append(MLPropDf, row)
# }
# MLPropDf <- as.data.frame(MLPropDf)
# MLProportionList <- as.data.frame(MLProportionList)
# MLProportionList <- MLProportionList %>% gather(year, value, -c(Code, Country))
# MLProportionList
# partData <- merge(partData, MLProportionList, by='Community')
# MLPropDf <- as.data.frame(MLPropDf) # ?????????
MLPropDf <- as.data.frame(unlist(MLProportionList))
MLPropDf
colnames(MLPropDf)
names(MLPropDf)[names(MLPropDf) == "unlist(MLProportionList)"] <- "proportionML"
MLPropDf$Community <- 1:nrow(MLPropDf)
MLPropDf$Community
partData <- merge(partData, MLPropDf, all=T, by='Community')
write.csv(partData, "../Data/community.csv")
